<!doctype html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

        <title>Babylon.js sample code</title>

        <!-- Babylon.js -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
        <script src="https://assets.babylonjs.com/generated/Assets.js"></script>
        <script src="https://cdn.babylonjs.com/recast.js"></script>
        <script src="https://cdn.babylonjs.com/ammo.js"></script>
        <script src="https://cdn.babylonjs.com/havok/HavokPhysics_umd.js"></script>
        <script src="https://cdn.babylonjs.com/cannon.js"></script>
        <script src="https://cdn.babylonjs.com/Oimo.js"></script>
        <script src="https://cdn.babylonjs.com/earcut.min.js"></script>
        <script src="https://cdn.babylonjs.com/babylon.js"></script>
        <script src="https://cdn.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
        <script src="https://cdn.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
        <script src="https://cdn.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
        <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.js"></script>
        <script src="https://cdn.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
        <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
        <script src="https://cdn.babylonjs.com/addons/babylonjs.addons.min.js"></script>
        <script src="https://cdn.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>

        <style>
            html,
            body {
                overflow: hidden;
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
            }

            #renderCanvas {
                width: 100%;
                height: 100%;
                touch-action: none;
            }

            #canvasZone {
                width: 100%;
                height: 100%;
            }
        </style>
    </head>
    <body>
        <div id="canvasZone"><canvas id="renderCanvas"></canvas></div>
        <script>
                    var canvas = document.getElementById("renderCanvas");

                    var startRenderLoop = function (engine, canvas) {
                        engine.runRenderLoop(function () {
                            if (sceneToRender && sceneToRender.activeCamera) {
                                sceneToRender.render();
                            }
                        });
                    }

                    var engine = null;
        var scene = null;
        var sceneToRender = null;
        var createDefaultEngine = function() { return new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true,  disableWebGL2Support: false}); };
        class UVUnwrappingPlugin extends BABYLON.MaterialPluginBase {
            constructor(material, { name = "uv_unwrapping_plugin", priority = 200, defines = { "UV_UNWRAPPING": true }, addToPluginList = true, enable = true, resolveIncludes = true }) {
                super(material, name, priority, defines, addToPluginList, enable, resolveIncludes);
                this._enable(true);
            }
            getClassName() {
                return "UVUnwrappingPlugin";
            }
            getAttributes(attr) {
                attr.push("uv2");
            }
            getCustomCode(shaderType) {
                if (shaderType === "vertex") {
                    return {
                        CUSTOM_VERTEX_DEFINITIONS: `
                    precision highp float;
                    attribute vec2 uv2;
                `,
                        CUSTOM_VERTEX_MAIN_END: `
                    #ifdef UV_UNWRAPPING
                        vec2 uvTransformed = (uv2 - 0.5) * 2.0;
                        gl_Position = vec4(uvTransformed.x, uvTransformed.y, 0.0, 1.0);
                    #endif
                `,
                    };
                }
            }
        }
        class Playground {
            static CreateScene(engine, canvas) {
                const scene = new BABYLON.Scene(engine);
                // Add lighting
                const light = new BABYLON.DirectionalLight("light", new BABYLON.Vector3(0, 1, 0), scene);
                light.intensity = 2.0;
                light.direction = new BABYLON.Vector3(0.3204164226684694, -0.897774797464629, -0.3022147069910482);
                light.autoCalcShadowZBounds = true;
                light.autoUpdateExtends = true;
                const shadowGenerator = new BABYLON.ShadowGenerator(1024, light);
                const camera = new BABYLON.ArcRotateCamera("camera1", 1.6018, 1.3705, 32, new BABYLON.Vector3(0, 0, 0), scene);
                camera.attachControl(canvas, true);
                camera.minZ = 0;
                // Create render target for UV unwrapping
                const uvRenderTarget = new BABYLON.RenderTargetTexture("uvTarget", 512, scene, false, true);
                const createUVMaterial = (originalMaterial) => {
                    const material = originalMaterial.clone("uv_" + originalMaterial.name);
                    new UVUnwrappingPlugin(material, {});
                    return material;
                };
                const uv1ToBox = (uv, index) => {
                    if (!uv || uv.length === 0) {
                        return { w: 0, h: 0, index, x: 0, y: 0, originalUv: uv };
                    }
                    // Calculate UV bounds
                    let minU = Infinity, maxU = -Infinity;
                    let minV = Infinity, maxV = -Infinity;
                    for (let i = 0; i < uv.length; i += 2) {
                        const u = uv[i];
                        const v = uv[i + 1];
                        minU = Math.min(minU, u);
                        maxU = Math.max(maxU, u);
                        minV = Math.min(minV, v);
                        maxV = Math.max(maxV, v);
                    }
                    return {
                        w: maxU - minU,
                        h: maxV - minV,
                        index,
                        x: 0,
                        y: 0,
                        originalUv: uv,
                        minU, maxU, minV, maxV
                    };
                };
                const boxToUv2 = (box, containerW, containerH) => {
                    if (!box.originalUv || box.originalUv.length === 0) {
                        return [];
                    }
                    const uv2 = new Float32Array(box.originalUv.length);
                    for (let i = 0; i < box.originalUv.length; i += 2) {
                        const u = box.originalUv[i];
                        const v = box.originalUv[i + 1];
                        // Normalize to 0-1 within original bounds
                        const normalizedU = (u - box.minU) / (box.maxU - box.minU);
                        const normalizedV = (v - box.minV) / (box.maxV - box.minV);
                        // Transform to packed position and normalize by container size
                        uv2[i] = (box.x + normalizedU * box.w) / containerW;
                        uv2[i + 1] = (box.y + normalizedV * box.h) / containerH;
                    }
                    return uv2;
                };
                const addMeshesToUVUnwrapping = (meshes, renderTarget) => {
                    const boxes = meshes.map((mesh, index) => uv1ToBox(mesh.getVerticesData(BABYLON.VertexBuffer.UVKind), index));
                    const { w, h } = potpack(boxes); // transform boxes in place
                    meshes?.forEach?.((mesh, index) => {
                        // Skip UV meshes, debug planes, and invalid meshes
                        if (!mesh || !mesh.getVerticesData ||
                            mesh.name.startsWith("uv_") ||
                            mesh.name.includes("debugPlane")) {
                            return;
                        }
                        // Set UV2 coordinates
                        const uv2 = boxToUv2(boxes[index], w, h);
                        mesh.setVerticesData(BABYLON.VertexBuffer.UV2Kind, uv2);
                        // Clone mesh for UV rendering
                        const uvMesh = mesh.clone("uv_" + mesh.name, null);
                        if (uvMesh) {
                            uvMesh.material = createUVMaterial(mesh.material);
                            if (!renderTarget.renderList) {
                                renderTarget.renderList = [];
                            }
                            renderTarget.renderList.push(uvMesh);
                        }
                    });
                };
                // Create debug plane to show the UV render target
                const debugPlane = BABYLON.MeshBuilder.CreatePlane("debugPlane", { size: 10 }, scene);
                debugPlane.position.z = 15;
                debugPlane.rotation.y = Math.PI; // Rotate 180 degrees
                const debugMaterial = new BABYLON.StandardMaterial("debugMat", scene);
                debugMaterial.backFaceCulling = false;
                debugMaterial.diffuseTexture = uvRenderTarget;
                debugMaterial.emissiveTexture = uvRenderTarget;
                debugPlane.material = debugMaterial;
                const ground = BABYLON.MeshBuilder.CreateGround("ground", { width: 30, height: 30 });
                ground.position.y = -3;
                const sphere1 = BABYLON.MeshBuilder.CreateIcoSphere("sphere1", { radius: 3 });
                const sphere2 = sphere1.clone("sphere2");
                const sphere3 = sphere1.clone("sphere3");
                sphere2.position.x = 7;
                sphere3.position.x = -7;
                sphere2.makeGeometryUnique();
                sphere3.makeGeometryUnique();
                const whiteMat = new BABYLON.StandardMaterial("whiteMat", scene);
                whiteMat.diffuseColor = BABYLON.Color3.White();
                const redMat = new BABYLON.StandardMaterial("redMat", scene);
                redMat.diffuseColor = BABYLON.Color3.Red();
                const greenMat = new BABYLON.StandardMaterial("greenMat", scene);
                greenMat.diffuseColor = BABYLON.Color3.Green();
                const blueMat = new BABYLON.StandardMaterial("blueMat", scene);
                blueMat.diffuseColor = BABYLON.Color3.Blue();
                ground.material = whiteMat;
                sphere1.material = greenMat;
                sphere2.material = redMat;
                sphere3.material = blueMat;
                shadowGenerator.addShadowCaster(sphere1);
                shadowGenerator.addShadowCaster(sphere2);
                shadowGenerator.addShadowCaster(sphere3);
                ground.receiveShadows = true;
                addMeshesToUVUnwrapping([ground, sphere1, sphere2, sphere3], uvRenderTarget);
                // Render UV layout
                setTimeout(() => {
                    if (uvRenderTarget.renderList && uvRenderTarget.renderList.length > 0) {
                        uvRenderTarget.render();
                        // Hide UV meshes from main scene
                        uvRenderTarget.renderList.forEach(mesh => mesh.isVisible = false);
                    }
                }, 500);
                return scene;
            }
        }
        /**
         * potpack - https://github.com/mapbox/potpack
         *
         * A tiny JavaScript function for packing 2D rectangles into a near-square container,
         * which is useful for generating CSS sprites and WebGL textures. Similar to
         * [shelf-pack](https://github.com/mapbox/shelf-pack), but static (you can't add items
         * once a layout is generated), and aims for maximal space utilization.
         *
         * A variation of algorithms used in [rectpack2D](https://github.com/TeamHypersomnia/rectpack2D)
         * and [bin-pack](https://github.com/bryanburgers/bin-pack), which are in turn based
         * on [this article by Blackpawn](http://blackpawn.com/texts/lightmaps/default.html).
         *
         * @license
         * ISC License
         *
         * Copyright (c) 2022, Mapbox
         *
         * Permission to use, copy, modify, and/or distribute this software for any purpose
         * with or without fee is hereby granted, provided that the above copyright notice
         * and this permission notice appear in all copies.
         *
         * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
         * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
         * FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
         * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS
         * OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
         * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
         * THIS SOFTWARE.
         */
        function potpack(boxes) {
            // calculate total box area and maximum box width
            let area = 0;
            let maxWidth = 0;
            for (const box of boxes) {
                area += box.w * box.h;
                maxWidth = Math.max(maxWidth, box.w);
            }
            // sort the boxes for insertion by height, descending
            boxes.sort((a, b) => b.h - a.h);
            // aim for a squarish resulting container,
            // slightly adjusted for sub-100% space utilization
            const startWidth = Math.max(Math.ceil(Math.sqrt(area / 0.95)), maxWidth);
            // start with a single empty space, unbounded at the bottom
            const spaces = [{ x: 0, y: 0, w: startWidth, h: Infinity }];
            let width = 0;
            let height = 0;
            for (const box of boxes) {
                // look through spaces backwards so that we check smaller spaces first
                for (let i = spaces.length - 1; i >= 0; i--) {
                    const space = spaces[i];
                    // look for empty spaces that can accommodate the current box
                    if (box.w > space.w || box.h > space.h)
                        continue;
                    // found the space; add the box to its top-left corner
                    // |-------|-------|
                    // |  box  |       |
                    // |_______|       |
                    // |         space |
                    // |_______________|
                    box.x = space.x;
                    box.y = space.y;
                    height = Math.max(height, box.y + box.h);
                    width = Math.max(width, box.x + box.w);
                    if (box.w === space.w && box.h === space.h) {
                        // space matches the box exactly; remove it
                        const last = spaces.pop();
                        if (i < spaces.length)
                            spaces[i] = last;
                    }
                    else if (box.h === space.h) {
                        // space matches the box height; update it accordingly
                        // |-------|---------------|
                        // |  box  | updated space |
                        // |_______|_______________|
                        space.x += box.w;
                        space.w -= box.w;
                    }
                    else if (box.w === space.w) {
                        // space matches the box width; update it accordingly
                        // |---------------|
                        // |      box      |
                        // |_______________|
                        // | updated space |
                        // |_______________|
                        space.y += box.h;
                        space.h -= box.h;
                    }
                    else {
                        // otherwise the box splits the space into two spaces
                        // |-------|-----------|
                        // |  box  | new space |
                        // |_______|___________|
                        // | updated space     |
                        // |___________________|
                        spaces.push({
                            x: space.x + box.w,
                            y: space.y,
                            w: space.w - box.w,
                            h: box.h
                        });
                        space.y += box.h;
                        space.h -= box.h;
                    }
                    break;
                }
            }
            return {
                w: width,
                h: height,
                fill: (area / (width * height)) || 0 // space utilization
            };
        }
        createScene = function() { return Playground.CreateScene(engine, engine.getRenderingCanvas()); }
                window.initFunction = async function() {
                    
                    
                    
                    var asyncEngineCreation = async function() {
                        try {
                        return createDefaultEngine();
                        } catch(e) {
                        console.log("the available createEngine function failed. Creating the default engine instead");
                        return createDefaultEngine();
                        }
                    }

                    window.engine = await asyncEngineCreation();
                    
                    const engineOptions = window.engine.getCreationOptions?.();
                    if (!engineOptions || engineOptions.audioEngine !== false) {
                        
                    }
        if (!engine) throw 'engine should not be null.';
        startRenderLoop(engine, canvas);
window.scene = createScene();};
        initFunction().then(() => {sceneToRender = scene
                    });

                    // Resize
                    window.addEventListener("resize", function () {
                        engine.resize();
                    });
        </script>
    </body>
</html>
